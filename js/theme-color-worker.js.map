{"version":3,"file":"theme-color-worker.js","mappings":"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","sources":["webpack://sakurairo-scripts/./node_modules/.pnpm/color-space@2.3.1/node_modules/color-space/rgb.js","webpack://sakurairo-scripts/./node_modules/.pnpm/color-space@2.3.1/node_modules/color-space/xyz.js","webpack://sakurairo-scripts/./node_modules/.pnpm/color-space@2.3.1/node_modules/color-space/lab.js","webpack://sakurairo-scripts/./node_modules/.pnpm/@kotorik+palette@3.0.4/node_modules/@kotorik/palette/dist/index.js","webpack://sakurairo-scripts/./node_modules/.pnpm/@kotorik+promise-worker@0.1.0/node_modules/@kotorik/promise-worker/dist/register.mjs","webpack://sakurairo-scripts/./src/app/theme-color/calc.ts"],"sourcesContent":["/**\n * RGB space.\n *\n * @module  color-space/rgb\n */\nconst rgb = {\n\tname: 'rgb',\n\tmin: [0, 0, 0],\n\tmax: [255, 255, 255],\n\tchannel: ['red', 'green', 'blue'],\n\talias: ['RGB']\n};\n\nexport default rgb;\n","/**\n * CIE XYZ\n *\n * @module  color-space/xyz\n */\nimport rgb from './rgb.js';\n\nconst xyz = {\n\tname: 'xyz',\n\tmin: [0, 0, 0],\n\tchannel: ['X', 'Y', 'Z'],\n\talias: ['XYZ', 'ciexyz', 'cie1931'],\n\n\t// Whitepoint reference values with observer/illuminant\n\t// http://en.wikipedia.org/wiki/Standard_illuminant\n\twhitepoint: {\n\t\t//1931 2°\n\t\t2: {\n\t\t\t//incadescent\n\t\t\tA: [109.85, 100, 35.585],\n\t\t\t// B:[],\n\t\t\tC: [98.074, 100, 118.232],\n\t\t\tD50: [96.422, 100, 82.521],\n\t\t\tD55: [95.682, 100, 92.149],\n\t\t\t//daylight\n\t\t\tD65: [95.045592705167, 100, 108.9057750759878],\n\t\t\tD75: [94.972, 100, 122.638],\n\t\t\t//flourescent\n\t\t\t// F1: [],\n\t\t\tF2: [99.187, 100, 67.395],\n\t\t\t// F3: [],\n\t\t\t// F4: [],\n\t\t\t// F5: [],\n\t\t\t// F6:[],\n\t\t\tF7: [95.044, 100, 108.755],\n\t\t\t// F8: [],\n\t\t\t// F9: [],\n\t\t\t// F10: [],\n\t\t\tF11: [100.966, 100, 64.370],\n\t\t\t// F12: [],\n\t\t\tE: [100, 100, 100]\n\t\t},\n\n\t\t//1964  10°\n\t\t10: {\n\t\t\t//incadescent\n\t\t\tA: [111.144, 100, 35.200],\n\t\t\tC: [97.285, 100, 116.145],\n\t\t\tD50: [96.720, 100, 81.427],\n\t\t\tD55: [95.799, 100, 90.926],\n\t\t\t//daylight\n\t\t\tD65: [94.811, 100, 107.304],\n\t\t\tD75: [94.416, 100, 120.641],\n\t\t\t//flourescent\n\t\t\tF2: [103.280, 100, 69.026],\n\t\t\tF7: [95.792, 100, 107.687],\n\t\t\tF11: [103.866, 100, 65.627],\n\t\t\tE: [100, 100, 100]\n\t\t}\n\t}\n};\n\n\n/**\n * Top values are the whitepoint’s top values, default are D65\n */\nxyz.max = xyz.whitepoint[2].D65;\n\n\n/**\n * Transform xyz to rgb\n *\n * @param {Array<number>} _xyz Array of xyz values\n * @param {Array<number>} white Whitepoint reference\n * @return {Array<number>} RGB values\n */\nxyz.rgb = function (_xyz, white) {\n\t// FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then\n\twhite = white || xyz.whitepoint[2].E;\n\n\tvar x = _xyz[0] / white[0],\n\t\ty = _xyz[1] / white[1],\n\t\tz = _xyz[2] / white[2],\n\t\tr, g, b;\n\n\t// assume sRGB\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tr = (x * 3.240969941904521) + (y * -1.537383177570093) + (z * -0.498610760293);\n\tg = (x * -0.96924363628087) + (y * 1.87596750150772) + (z * 0.041555057407175);\n\tb = (x * 0.055630079696993) + (y * -0.20397695888897) + (z * 1.056971514242878);\n\n\tr = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r = (r * 12.92);\n\n\tg = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g = (g * 12.92);\n\n\tb = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b = (b * 12.92);\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n}\n\n\n\n/**\n * RGB to XYZ\n *\n * @param {Array<number>} rgb RGB channels\n *\n * @return {Array<number>} XYZ channels\n */\nrgb.xyz = function (rgb, white) {\n\tvar r = rgb[0] / 255,\n\t\tg = rgb[1] / 255,\n\t\tb = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.41239079926595) + (g * 0.35758433938387) + (b * 0.18048078840183);\n\tvar y = (r * 0.21263900587151) + (g * 0.71516867876775) + (b * 0.072192315360733);\n\tvar z = (r * 0.019330818715591) + (g * 0.11919477979462) + (b * 0.95053215224966);\n\n\twhite = white || xyz.whitepoint[2].E;\n\n\treturn [x * white[0], y * white[1], z * white[2]];\n};\n\n\n\nexport default xyz;\n","/**\n * CIE LAB space model\n *\n * @module color-space/lab\n */\n\nimport xyz from './xyz.js';\n\nvar lab = {\n\tname: 'lab',\n\tmin: [0, -100, -100],\n\tmax: [100, 100, 100],\n\tchannel: ['lightness', 'a', 'b'],\n\talias: ['LAB', 'cielab'],\n}\n\nlab.xyz = ([l, a, b]) => {\n\tvar x, y, z, y2;\n\n\tif (l <= 8) {\n\t\ty = (l * 100) / 903.3;\n\t\ty2 = (7.787 * (y / 100)) + (16 / 116);\n\t} else {\n\t\ty = 100 * Math.pow((l + 16) / 116, 3);\n\t\ty2 = Math.pow(y / 100, 1 / 3);\n\t}\n\n\tx = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n\tz = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n\treturn [x, y, z];\n}\n\n\nexport default (lab);\n\n\nxyz.lab = ([x, y, z]) => {\n\tvar l, a, b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n","import rgb from 'color-space/rgb.js';\nimport xyz from 'color-space/xyz.js';\nimport lab from 'color-space/lab.js';\n\nfunction _filled_array(fillWith, count) {\n  const array = [];\n  for (let i = 0; i < count; i++) {\n    array.push(fillWith);\n  }\n  return array;\n}\nfunction euclidean_distance_squared_index(a, a_start, b) {\n  const r = a[a_start++] - b[0];\n  const g = a[a_start++] - b[1];\n  const _b = a[a_start++] - b[2];\n  return r ** 2 + g ** 2 + _b ** 2;\n}\nfunction kmeans(data, k, maxAttempt, thresold = 2, clipAlpha = false) {\n  const cluster_sum = [];\n  const thresold_squared = thresold ** 2;\n  let pixelCount = data.length / 4;\n  let cluster_centers = [];\n  let new_cluster_centers = [];\n  let iteration = 0;\n  const isDataTypedArray = data instanceof Uint8ClampedArray;\n  const PIXEL_LEN = clipAlpha ? 3 : 4;\n  if (clipAlpha) {\n    let j = 0;\n    const dataNoAlpha = isDataTypedArray ? new Uint8ClampedArray(pixelCount * 3) : [];\n    for (let i = 0; i < data.length; ) {\n      if (data[i + 3] == 0) {\n        i += 4;\n        continue;\n      }\n      dataNoAlpha[j++] = data[i++];\n      dataNoAlpha[j++] = data[i++];\n      dataNoAlpha[j++] = data[i++];\n      i++;\n    }\n    data = dataNoAlpha.slice(0, j);\n    pixelCount = j / 3;\n  }\n  for (let i = 0; i < k; i++) {\n    const start = Math.floor(1 * (pixelCount - 1)) * PIXEL_LEN;\n    cluster_centers.push(\n      /* Array.from */\n      data.slice(start, start + 3)\n    );\n    new_cluster_centers.push(isDataTypedArray ? new Uint8ClampedArray(3) : _filled_array(0, 3));\n    cluster_sum.push(_filled_array(0, 4));\n  }\n  while (iteration < maxAttempt) {\n    for (let i = 0; i < data.length; ) {\n      let cluster_index = 0;\n      let _min_distance = euclidean_distance_squared_index(data, i, cluster_centers[0]);\n      for (let j = 1; j < k; j++) {\n        const distance = euclidean_distance_squared_index(data, i, cluster_centers[j]);\n        if (distance < _min_distance) {\n          _min_distance = distance;\n          cluster_index = j;\n        }\n      }\n      const sum = cluster_sum[cluster_index];\n      sum[0] += data[i++];\n      sum[1] += data[i++];\n      sum[2] += data[i++];\n      sum[3]++;\n      if (PIXEL_LEN === 4) i++;\n    }\n    let allStabled = true;\n    for (let i = 0; i < k; i++) {\n      const rgbc = cluster_sum[i];\n      const count = rgbc[3];\n      if (count == 0) {\n        const start = Math.floor(Math.random() * (pixelCount - 1)) * PIXEL_LEN;\n        new_cluster_centers[i] = /* Array.from */\n        data.slice(start, start + 3);\n        allStabled = false;\n      } else {\n        let new_center = new_cluster_centers[i];\n        let diffSquared = 0;\n        for (let j = 0; j < 3; j++) {\n          new_center[j] = rgbc[j] / count;\n          diffSquared += (new_center[j] - cluster_centers[i][j]) ** 2;\n        }\n        if (diffSquared > thresold_squared) {\n          allStabled = false;\n        }\n      }\n    }\n    if (allStabled) {\n      return {\n        centroid: new_cluster_centers,\n        iteration,\n        fit: true,\n        label: cluster_sum.map((v) => v[3]),\n        size: pixelCount\n      };\n    }\n    const medium = cluster_centers;\n    cluster_centers = new_cluster_centers;\n    new_cluster_centers = medium;\n    iteration++;\n    for (let i = 0; i < k; i++) {\n      cluster_sum[i].fill(0);\n    }\n  }\n  return {\n    centroid: cluster_centers,\n    iteration,\n    fit: false,\n    label: cluster_sum.map((v) => v[3]),\n    size: pixelCount\n  };\n}\n\n/**\n * NeuQuant Neural-Network Quantization Algorithm\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * See \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * See also http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * Copyright (c) 2012 Johan Nordberg (JavaScript port)\n * Copyright (c) 2014 Devon Govett (JavaScript port)\n */\n\nconst prime1 = 499;\nconst prime2 = 491;\nconst prime3 = 487;\nconst prime4 = 503;\n\nconst maxprime = Math.max(prime1, prime2, prime3, prime4);\nconst minpicturebytes = (3 * maxprime);\n\nconst defaults = {\n  ncycles: 100,\n  netsize: 256,\n  samplefac: 10\n};\n\nconst assign = function (target) {\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    const nextSource = arguments[i];\n    if (nextSource != null) {\n      for (const nextKey in nextSource) {\n        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n          target[nextKey] = nextSource[nextKey];\n        }\n      }\n    }\n  }\n  return target\n};\n\nclass NeuQuant {\n  constructor (pixels, options) {\n    assign(this, defaults, {pixels}, options);\n\n    if (this.netsize < 4 || this.netsize > 256) {\n      throw new Error('Color count must be between 4 and 256')\n    }\n\n    if (this.samplefac < 1 || this.samplefac > 30) {\n      throw new Error('Sampling factor must be between 1 and 30')\n    }\n\n    this.maxnetpos = this.netsize - 1;\n\n    this.netbiasshift = 4;\n    this.intbiasshift = 16;\n    this.intbias = (1 << this.intbiasshift);\n    this.gammashift = 10;\n    this.gamma = (1 << this.gammashift);\n    this.betashift = 10;\n    this.beta = (this.intbias >> this.betashift);\n    this.betagamma = (this.beta * this.gamma);\n\n    this.initrad = (this.netsize >> 3);\n    this.radiusbiasshift = 6;\n    this.radiusbias = (1 << this.radiusbiasshift);\n    this.initradius = (this.initrad * this.radiusbias);\n    this.radiusdec = 30;\n\n    this.alphabiasshift = 10;\n    this.initalpha = (1 << this.alphabiasshift);\n\n    this.radbiasshift = 8;\n    this.radbias = (1 << this.radbiasshift);\n    this.alpharadbshift = (this.alphabiasshift + this.radbiasshift);\n    this.alpharadbias = (1 << this.alpharadbshift);\n\n    this.network = [];\n    this.netindex = new Uint32Array(256);\n    this.bias = new Uint32Array(this.netsize);\n    this.freq = new Uint32Array(this.netsize);\n    this.radpower = new Uint32Array(this.netsize >> 3);\n\n    for (let i = 0, l = this.netsize; i < l; i++) {\n      let v = (i << (this.netbiasshift + 8)) / this.netsize;\n      this.network[i] = new Float64Array([v, v, v, 0]);\n      this.freq[i] = this.intbias / this.netsize;\n      this.bias[i] = 0;\n    }\n  }\n\n  unbiasnet () {\n    for (let i = 0, l = this.netsize; i < l; i++) {\n      this.network[i][0] >>= this.netbiasshift;\n      this.network[i][1] >>= this.netbiasshift;\n      this.network[i][2] >>= this.netbiasshift;\n      this.network[i][3] = i;\n    }\n  }\n\n  altersingle (alpha, i, b, g, r) {\n    this.network[i][0] -= (alpha * (this.network[i][0] - b)) / this.initalpha;\n    this.network[i][1] -= (alpha * (this.network[i][1] - g)) / this.initalpha;\n    this.network[i][2] -= (alpha * (this.network[i][2] - r)) / this.initalpha;\n  }\n\n  alterneigh (radius, i, b, g, r) {\n    const lo = Math.abs(i - radius);\n    const hi = Math.min(i + radius, this.netsize);\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while ((j < hi) || (k > lo)) {\n      const a = this.radpower[m++];\n\n      if (j < hi) {\n        const p = this.network[j++];\n        p[0] -= (a * (p[0] - b)) / this.alpharadbias;\n        p[1] -= (a * (p[1] - g)) / this.alpharadbias;\n        p[2] -= (a * (p[2] - r)) / this.alpharadbias;\n      }\n\n      if (k > lo) {\n        const p = this.network[k--];\n        p[0] -= (a * (p[0] - b)) / this.alpharadbias;\n        p[1] -= (a * (p[1] - g)) / this.alpharadbias;\n        p[2] -= (a * (p[2] - r)) / this.alpharadbias;\n      }\n    }\n  }\n\n  contest (b, g, r) {\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0, l = this.netsize; i < l; i++) {\n      let n = this.network[i];\n\n      let dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      let biasdist = dist - ((this.bias[i]) >> (this.intbiasshift - this.netbiasshift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      let betafreq = (this.freq[i] >> this.betashift);\n      this.freq[i] -= betafreq;\n      this.bias[i] += (betafreq << this.gammashift);\n    }\n\n    this.freq[bestpos] += this.beta;\n    this.bias[bestpos] -= this.betagamma;\n\n    return bestbiaspos\n  }\n\n  inxbuild () {\n    let previouscol = 0;\n    let startpos = 0;\n\n    for (let i = 0, l = this.netsize; i < l; i++) {\n      let p = this.network[i];\n      let q = null;\n      let smallpos = i;\n      let smallval = p[1];\n\n      for (let j = i + 1; j < l; j++) {\n        q = this.network[j];\n        if (q[1] < smallval) {\n          smallpos = j;\n          smallval = q[1];\n        }\n      }\n      q = this.network[smallpos];\n\n      if (i !== smallpos) {\n        [p[0], q[0]] = [q[0], p[0]];\n        [p[1], q[1]] = [q[1], p[1]];\n        [p[2], q[2]] = [q[2], p[2]];\n        [p[3], q[3]] = [q[3], p[3]];\n      }\n\n      if (smallval !== previouscol) {\n        this.netindex[previouscol] = (startpos + i) >> 1;\n        for (let j = previouscol + 1; j < smallval; j++) {\n          this.netindex[j] = i;\n        }\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    this.netindex[previouscol] = (startpos + this.maxnetpos) >> 1;\n    for (let i = previouscol + 1; i < 256; i++) {\n      this.netindex[i] = this.maxnetpos;\n    }\n  }\n\n  learn () {\n    const lengthcount = this.pixels.length;\n    const alphadec = 30 + ((this.samplefac - 1) / 3);\n    const samplepixels = lengthcount / (3 * this.samplefac);\n\n    let delta = samplepixels / this.ncycles | 0;\n    let alpha = this.initalpha;\n    let radius = this.initradius;\n\n    let rad = radius >> this.radiusbiasshift;\n\n    if (rad <= 1) {\n      rad = 0;\n    }\n\n    for (let i = 0; i < rad; i++) {\n      this.radpower[i] = alpha * (((rad * rad - i * i) * this.radbias) / (rad * rad));\n    }\n\n    let step;\n    if (lengthcount < minpicturebytes) {\n      this.samplefac = 1;\n      step = 3;\n    } else if ((lengthcount % prime1) !== 0) {\n      step = 3 * prime1;\n    } else if ((lengthcount % prime2) !== 0) {\n      step = 3 * prime2;\n    } else if ((lengthcount % prime3) !== 0) {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    let pix = 0;\n\n    for (let i = 0; i < samplepixels;) {\n      let b = (this.pixels[pix] & 0xff) << this.netbiasshift;\n      let g = (this.pixels[pix + 1] & 0xff) << this.netbiasshift;\n      let r = (this.pixels[pix + 2] & 0xff) << this.netbiasshift;\n\n      let j = this.contest(b, g, r);\n      this.altersingle(alpha, j, b, g, r);\n      if (rad !== 0) {\n        this.alterneigh(rad, j, b, g, r);\n      }\n\n      pix += step;\n      if (pix >= lengthcount) {\n        pix -= lengthcount;\n      }\n\n      if (delta === 0) {\n        delta = 1;\n      }\n\n      if (++i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / this.radiusdec;\n        rad = radius >> this.radiusbiasshift;\n\n        if (rad <= 1) {\n          rad = 0;\n        }\n\n        for (let k = 0; k < rad; k++) {\n          this.radpower[k] = alpha * (((rad * rad - k * k) * this.radbias) / (rad * rad));\n        }\n      }\n    }\n  }\n\n  buildColorMap () {\n    this.learn();\n    this.unbiasnet();\n    this.inxbuild();\n  }\n\n  getColorMap () {\n    const map = new Uint8Array(this.netsize * 3);\n    const index = new Uint8Array(this.netsize);\n\n    for (let i = 0, l = this.netsize; i < l; i++) {\n      index[this.network[i][3]] = i;\n    }\n\n    for (let i = 0, j = 0, k = 0, l = this.netsize; i < l; i++) {\n      k = index[i];\n      map[j++] = this.network[k][0] & 0xff;\n      map[j++] = this.network[k][1] & 0xff;\n      map[j++] = this.network[k][2] & 0xff;\n    }\n\n    return map\n  }\n}\n\nfunction findClosest (palette, r, g, b) {\n  let minpos = 0;\n  let mind = 256 * 256 * 256;\n\n  for (let i = 0, l = palette.length; i < l;) {\n    const dr = r - palette[i++];\n    const dg = g - palette[i++];\n    const db = b - palette[i];\n    const d = dr * dr + dg * dg + db * db;\n    const pos = i / 3 | 0;\n\n    if (d < mind) {\n      mind = d;\n      minpos = pos;\n    }\n\n    i++;\n  }\n\n  return minpos\n}\n\nfunction palette (pixels, options) {\n  const nq = new NeuQuant(pixels, options);\n  nq.buildColorMap();\n  return nq.getColorMap()\n}\n\nfunction indexed (pixels, palette) {\n  const indexed = new Uint8Array(pixels.length / 3);\n  const memo = {};\n\n  for (let i = 0, j = 0, l = pixels.length; i < l;) {\n    const r = pixels[i++];\n    const g = pixels[i++];\n    const b = pixels[i++];\n    const k = r << 16 | g << 8 | b;\n\n    if (k in memo) {\n      indexed[j++] = memo[k];\n    } else {\n      indexed[j++] = memo[k] = findClosest(palette, r, g, b);\n    }\n  }\n\n  return indexed\n}\n\nfunction rgba2Rgb(data) {\n  const rgb = new Uint8ClampedArray(data.length / 4 * 3);\n  const len = data.length;\n  let rgb_i = 0;\n  for (let i = 0; i < len; ) {\n    for (let j = 0; j < 3; j++) {\n      rgb[rgb_i++] = data[i++];\n    }\n    i++;\n  }\n  return rgb;\n}\nfunction neuquant(img, k, samplefac = 1) {\n  const img_rgb = rgba2Rgb(img);\n  const palette$1 = palette(img_rgb, { netsize: k, samplefac });\n  const indexed_pixel = indexed(img_rgb, palette$1);\n  const pixel = [];\n  const len = palette$1.length;\n  for (let i = 0; i < len; ) {\n    pixel.push([palette$1[i++], palette$1[i++], palette$1[i++], 255]);\n  }\n  return { centroid: pixel, label: count(k, indexed_pixel) };\n}\nfunction count(k, index) {\n  const counts = new Array(k).fill(0);\n  for (const i of index) {\n    counts[i]++;\n  }\n  return counts;\n}\n\nfunction _prepare2DContext(width, height) {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.height = height;\n  canvas.width = width;\n  return ctx;\n}\nfunction _prepare2DContextAsync(width, height) {\n  const canvas = new OffscreenCanvas(width, height);\n  const ctx = canvas.getContext(\"2d\");\n  return ctx;\n}\nfunction awaitImage(imgElement) {\n  return new Promise((resolve, reject) => {\n    if (imgElement.complete) {\n      resolve();\n    } else {\n      imgElement.addEventListener(\"load\", (e) => {\n        resolve(e);\n      });\n      imgElement.addEventListener(\"error\", (reason) => {\n        reject(reason);\n      });\n    }\n  });\n}\nfunction _readImage(prepareCtx, imgSource) {\n  const { naturalWidth, naturalHeight } = imgSource;\n  const ctx = prepareCtx(naturalWidth, naturalHeight);\n  ctx.drawImage(imgSource, 0, 0, naturalWidth, naturalHeight);\n  return ctx.getImageData(0, 0, naturalWidth, naturalHeight);\n}\nconst readImage = _readImage.bind(void 0, _prepare2DContext);\nconst readImageOffscreen = _readImage.bind(void 0, _prepare2DContextAsync);\nfunction _readImageDownsampling(prepareCtx, imgSource, maxSample) {\n  let { naturalWidth: width, naturalHeight: height } = imgSource;\n  const scale = width * height / maxSample;\n  if (scale > 1) {\n    const scaleSqrt = Math.sqrt(scale);\n    width = width / scaleSqrt | 0;\n    height = height / scaleSqrt | 0;\n  }\n  const ctx = prepareCtx(width, height);\n  ctx.drawImage(imgSource, 0, 0, width, height);\n  return ctx.getImageData(0, 0, width, height);\n}\nconst readImageDownsampling = _readImageDownsampling.bind(void 0, _prepare2DContext);\nconst readImageDownsamplingOffscreen = _readImageDownsampling.bind(void 0, _prepare2DContextAsync);\n\nfunction convertToLab(source) {\n  const array = [];\n  for (let i = 0; i < source.length; i += 4) {\n    const pixel = source.slice(i, i + 4);\n    const alpha = pixel[3];\n    const pixel_rgb = pixel.slice(0, 3);\n    const pixel_xyz = rgb.xyz(pixel_rgb);\n    const pixel_lab = xyz.lab(pixel_xyz);\n    array.push(...pixel_lab, alpha);\n  }\n  return array;\n}\nfunction labaToRGBA(laba) {\n  const pixel_lab = laba.slice(0, 3);\n  const alpha = laba[3];\n  const pixel_xyz = lab.xyz(pixel_lab);\n  const pixel_rgb = xyz.rgb(pixel_xyz);\n  pixel_rgb.push(alpha);\n  return pixel_rgb;\n}\n\nfunction max_min_of_three([a, b, c]) {\n  if (a > b) {\n    if (b > c) {\n      return [a, c];\n    } else {\n      if (a > c) {\n        return [a, b];\n      } else {\n        return [c, b];\n      }\n    }\n  } else {\n    if (b > c) {\n      if (c > a) {\n        return [b, a];\n      } else {\n        return [b, c];\n      }\n    } else {\n      return [c, a];\n    }\n  }\n}\n\nfunction normalizeRGBA(rgba) {\n  return rgba.map((v) => v / 255);\n}\nfunction rgbaToHSLA(rgba) {\n  let h, s;\n  const [max, min] = max_min_of_three(rgba);\n  const diff = max - min;\n  const light_2x = max + min;\n  if (diff == 0) {\n    h = 0;\n    s = 0;\n  } else {\n    if (max == rgba[0]) {\n      const temp_h = 60 * (rgba[1] - rgba[2]) / diff;\n      if (temp_h < 0) {\n        h = temp_h + 360;\n      } else {\n        h = temp_h;\n      }\n    } else if (max == rgba[1]) {\n      h = 60 * (rgba[2] - rgba[0]) / diff + 120;\n    } else {\n      h = 60 * (rgba[0] - rgba[1]) / diff + 240;\n    }\n    if (light_2x == 0) {\n      s = 0;\n    } else if (light_2x <= 1) {\n      s = diff / light_2x;\n    } else {\n      s = diff / (2 - light_2x);\n    }\n  }\n  return [h, s, light_2x / 2, rgba[3]];\n}\nconst getVector4Comparer = (sort = [0, 1, 2, 3]) => (a, b) => {\n  let result;\n  for (const s of sort) {\n    result = a[s] - b[s];\n    if (result != 0) {\n      return result;\n    }\n  }\n  return result;\n};\nconst hslaCSSText = ([h, s, l, a]) => `hsla(${h}deg,${s * 100}%,${l * 100}%,${a})`;\nconst rgbaCSSText = (pixel) => `rgba(${pixel.map((v) => Math.floor(v)).join(\",\")})`;\n\nexport { awaitImage, convertToLab, getVector4Comparer, hslaCSSText, kmeans, labaToRGBA, neuquant, normalizeRGBA, readImage, readImageDownsampling, readImageDownsamplingOffscreen, readImageOffscreen, rgbaCSSText, rgbaToHSLA };\n","export default function registerPromiseWorker(callback) {\n    self.addEventListener('message', async (e) => {\n        const payload = e.data;\n        const messageId = payload[0];\n        const message = payload[1];\n        try {\n            const transferList = [];\n            const callbackResult = await callback(message, (t) => transferList.push(t));\n            self.postMessage([messageId, null, callbackResult], transferList.length ? { transfer: transferList } : undefined);\n        }\n        catch (error) {\n            self.postMessage([messageId, {\n                    message: error.message\n                }]);\n        }\n    });\n}\n","import { neuquant } from '@kotorik/palette';\nexport default function neuquantCalc(data) {\n    const { label, centroid } = neuquant(data, 8);\n    const max = Math.max(...label);\n    const index = label.findIndex(value => value == max);\n    return centroid[index];\n}\n"],"names":["name","min","max","channel","alias","whitepoint","A","C","D50","D55","D65","D75","F2","F7","F11","E","rgb","_xyz","white","r","g","b","x","y","z","Math","pow","xyz","lab","minpicturebytes","defaults","ncycles","netsize","samplefac","NeuQuant","constructor","pixels","options","target","i","l","arguments","length","nextSource","nextKey","Object","prototype","hasOwnProperty","call","this","Error","maxnetpos","netbiasshift","intbiasshift","intbias","gammashift","gamma","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","radbiasshift","radbias","alpharadbshift","alpharadbias","network","netindex","Uint32Array","bias","freq","radpower","v","Float64Array","unbiasnet","altersingle","alpha","alterneigh","radius","lo","abs","hi","j","k","m","a","p","contest","bestd","bestbiasd","bestpos","bestbiaspos","n","dist","biasdist","betafreq","inxbuild","previouscol","startpos","q","smallpos","smallval","learn","lengthcount","alphadec","samplepixels","step","delta","rad","pix","buildColorMap","getColorMap","map","Uint8Array","index","findClosest","palette","minpos","mind","dr","dg","db","d","neuquant","img","img_rgb","data","Uint8ClampedArray","len","rgb_i","rgba2Rgb","palette$1","nq","indexed_pixel","indexed","memo","pixel","push","centroid","label","count","counts","Array","fill","_prepare2DContext","width","height","canvas","document","createElement","ctx","getContext","_prepare2DContextAsync","OffscreenCanvas","_readImage","prepareCtx","imgSource","naturalWidth","naturalHeight","drawImage","getImageData","bind","_readImageDownsampling","maxSample","scale","scaleSqrt","sqrt","callback","findIndex","value","self","addEventListener","async","e","payload","messageId","message","transferList","callbackResult","t","postMessage","transfer","undefined","error"],"sourceRoot":""}